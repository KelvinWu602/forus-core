package helpers

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/hex"
	"fmt"
	"math/rand"
	"time"
)

const charSet = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// create a seeded Random number of type Rand
var seededRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))

// "crypto/rsa"
// "crypto/rand"

// ECC: notion read.me

// Public Key Private Key Generation using rsa package
// 1) Generate a private key with PrivateKey by rsa.GenerateKey(rand.Reader, RANDOM_SIZE)
// 2) The public key is generated at the same time in (1) via rsa.PrivateKey.PublicKey

// Symmetry Key Generation using aes package and random package
// 1) a secret key is needed for AES, which is generated by generateSecretKey()

// How to generate secret key with one node
// 1) receive the public key of one
// a, _ := puba.Curve.ScalarMult(puba.X, puba.Y, privb.D.Bytes())
// shared1 := sha256.Sum256(a.Bytes())
//

type SecretKey []byte

func PKCS5UnPadding(src []byte) []byte {
	length := len(src)
	unpadding := int(src[length-1])

	return src[:(length - unpadding)]
}

func generateSecretKey(length int, charset string) SecretKey {
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return b
}

func encryptAES(key SecretKey, plaintext string) (string, error) {
	// iv := "my16digitIvKey12"
	cipher, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	output := make(SecretKey, len(plaintext))
	cipher.Encrypt(output, []byte(plaintext))
	return hex.EncodeToString(output), nil

}

func decryptAES(key SecretKey, ciphertext []byte) ([]byte, error) {
	iv := "my16digitIvKey12"
	block, err := aes.NewCipher(key)
	if err != nil {
		return []byte("Error when creating NewCipher"), err
	}
	if len(ciphertext)%aes.BlockSize != 0 {
		return []byte("Blocksize Zero Error"), fmt.Errorf("Blocksize Zero Error")
	}
	mode := cipher.NewCBCDecrypter(block, []byte(iv))
	mode.CryptBlocks(ciphertext, ciphertext)
	ciphertext = PKCS5UnPadding(ciphertext)
	return ciphertext, nil

}

type KeyExchange struct {
}
